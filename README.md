------------------------------------------------------------
-- 0) Tablas de apoyo para auditoría
------------------------------------------------------------
DROP TABLE auditoria_eventos PURGE;
DROP TABLE auditoria_detalle PURGE;

CREATE TABLE auditoria_eventos (
  id_evento NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  usuario    VARCHAR2(100),
  operacion  VARCHAR2(30),        -- INSERT / UPDATE / DELETE
  fecha      DATE DEFAULT SYSDATE
);

CREATE TABLE auditoria_detalle (
  id_detalle NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_evento  NUMBER REFERENCES auditoria_eventos(id_evento),
  id_libro   NUMBER,
  campo      VARCHAR2(50),
  valor_old  VARCHAR2(200),
  valor_new  VARCHAR2(200)
);

------------------------------------------------------------
-- 1) PROCEDIMIENTOS
------------------------------------------------------------

-- 1.1 Procedimiento SIN parámetros (procesa en masa):
-- Revaloriza todos los libros de una categoría en un % dado (constante interna).
CREATE OR REPLACE PROCEDURE sp_revalorizar_categoria_default IS
  v_id_categoria NUMBER := 1;     -- por defecto: Novela
  v_porcentaje   NUMBER := 0.10;  -- +10%
BEGIN
  UPDATE libros
     SET precio = ROUND(precio * (1 + v_porcentaje), 2)
   WHERE id_categoria = v_id_categoria;

  DBMS_OUTPUT.PUT_LINE('Revalorizados libros de categoría '||v_id_categoria||
                       ' en '||(v_porcentaje*100)||'%');
END;
/

-- 1.2 Procedimiento CON parámetros:
-- Ajusta stock (suma o resta) de un libro validando no-negatividad.
CREATE OR REPLACE PROCEDURE sp_ajustar_stock(
  p_id_libro IN NUMBER,
  p_delta    IN NUMBER
) IS
  v_stock_actual NUMBER;
BEGIN
  SELECT stock INTO v_stock_actual FROM libros WHERE id_libro = p_id_libro FOR UPDATE;

  IF v_stock_actual + p_delta < 0 THEN
    RAISE_APPLICATION_ERROR(-20001, 'Stock resultante no puede ser negativo');
  END IF;

  UPDATE libros
     SET stock = stock + p_delta
   WHERE id_libro = p_id_libro;

  DBMS_OUTPUT.PUT_LINE('Stock ajustado. Libro '||p_id_libro||
                       ' delta='||p_delta||' nuevo_stock='||(v_stock_actual+p_delta));
END;
/

-- 1.3 Procedimiento CON parámetros:
-- Inserta un nuevo libro (demuestra uso de varios parámetros).
CREATE OR REPLACE PROCEDURE sp_registrar_libro(
  p_id_libro    IN NUMBER,
  p_titulo      IN VARCHAR2,
  p_id_autor    IN NUMBER,
  p_id_categoria IN NUMBER,
  p_precio      IN NUMBER,
  p_stock       IN NUMBER
) IS
BEGIN
  IF p_precio < 0 OR p_stock < 0 THEN
    RAISE_APPLICATION_ERROR(-20002, 'Precio/stock no pueden ser negativos');
  END IF;

  INSERT INTO libros(id_libro, titulo, id_autor, id_categoria, precio, stock)
  VALUES (p_id_libro, p_titulo, p_id_autor, p_id_categoria, p_precio, p_stock);

  DBMS_OUTPUT.PUT_LINE('Libro registrado: '||p_titulo);
END;
/

------------------------------------------------------------
-- 2) FUNCIONES
------------------------------------------------------------

-- 2.1 Devuelve el stock disponible de un libro
CREATE OR REPLACE FUNCTION fn_stock_disponible(p_id_libro IN NUMBER)
RETURN NUMBER IS
  v_stock NUMBER;
BEGIN
  SELECT stock INTO v_stock FROM libros WHERE id_libro = p_id_libro;
  RETURN v_stock;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN NULL;
END;
/

-- 2.2 Valor total de inventario por categoría (SUM(precio*stock))
CREATE OR REPLACE FUNCTION fn_valor_inventario_categoria(p_id_categoria IN NUMBER)
RETURN NUMBER IS
  v_total NUMBER;
BEGIN
  SELECT SUM(precio * stock) INTO v_total
    FROM libros
   WHERE id_categoria = p_id_categoria;
  RETURN NVL(v_total,0);
END;
/

------------------------------------------------------------
-- 3) PACKAGE con parte pública y privada
------------------------------------------------------------

-- 3.1 Especificación (pública)
CREATE OR REPLACE PACKAGE pkg_inventario AS
  -- Constantes públicas
  c_max_stock CONSTANT NUMBER := 99999;

  -- Tipos públicos
  TYPE t_resumen IS RECORD(
    total_libros NUMBER,
    total_valor  NUMBER
  );

  -- Procedimientos/funciones públicas
  PROCEDURE ajustar_stock_seguro(p_id_libro IN NUMBER, p_delta IN NUMBER);
  FUNCTION  resumen_categoria(p_id_categoria IN NUMBER) RETURN t_resumen;

END pkg_inventario;
/

-- 3.2 Cuerpo (define privados y la implementación)
CREATE OR REPLACE PACKAGE BODY pkg_inventario AS

  -- *** Sección PRIVADA ***
  -- Valida rangos y reglas internas
  PROCEDURE pr_validar_stock(p_nuevo_stock IN NUMBER) IS
  BEGIN
    IF p_nuevo_stock < 0 THEN
      RAISE_APPLICATION_ERROR(-20003, 'Stock negativo no permitido');
    ELSIF p_nuevo_stock > c_max_stock THEN
      RAISE_APPLICATION_ERROR(-20004, 'Stock excede limite maximo');
    END IF;
  END;

  -- Inserta cabecera de evento y devuelve id_evento
  FUNCTION pr_insert_evento(p_operacion IN VARCHAR2)
  RETURN NUMBER IS
    v_id NUMBER;
  BEGIN
    INSERT INTO auditoria_eventos(usuario, operacion)
    VALUES (USER, p_operacion)
    RETURNING id_evento INTO v_id;
    RETURN v_id;
  END;

  -- *** Sección PÚBLICA ***
  PROCEDURE ajustar_stock_seguro(p_id_libro IN NUMBER, p_delta IN NUMBER) IS
    v_stock NUMBER;
    v_id_e  NUMBER;
  BEGIN
    SELECT stock INTO v_stock FROM libros WHERE id_libro = p_id_libro FOR UPDATE;
    pr_validar_stock(v_stock + p_delta);

    v_id_e := pr_insert_evento('AJUSTE_STOCK');

    UPDATE libros
       SET stock = stock + p_delta
     WHERE id_libro = p_id_libro;

    INSERT INTO auditoria_detalle(id_evento, id_libro, campo, valor_old, valor_new)
    VALUES (v_id_e, p_id_libro, 'stock', TO_CHAR(v_stock), TO_CHAR(v_stock + p_delta));
  END;

  FUNCTION resumen_categoria(p_id_categoria IN NUMBER)
  RETURN t_resumen IS
    v_r t_resumen;
  BEGIN
    SELECT COUNT(*), NVL(SUM(precio*stock),0)
      INTO v_r.total_libros, v_r.total_valor
      FROM libros
     WHERE id_categoria = p_id_categoria;
    RETURN v_r;
  END;

END pkg_inventario;
/

------------------------------------------------------------
-- 4) TRIGGERS: nivel SENTENCIA y nivel FILA
------------------------------------------------------------

-- 4.1 Trigger a NIVEL SENTENCIA:
-- Registra un evento por cada UPDATE masivo sobre LIBROS (una fila en cabecera).
CREATE OR REPLACE TRIGGER trg_libros_bu_stmt
BEFORE UPDATE ON libros
DECLARE
  PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
  INSERT INTO auditoria_eventos(usuario, operacion) VALUES (USER, 'UPDATE_LIBROS');
  COMMIT;
END;
/

-- 4.2 Trigger a NIVEL FILA:
-- Registra cada cambio de precio/stock en detalle (por fila).
CREATE OR REPLACE TRIGGER trg_libros_bu_row
BEFORE UPDATE OF precio, stock ON libros
FOR EACH ROW
DECLARE
  PRAGMA AUTONOMOUS_TRANSACTION;
  v_id_evento NUMBER;
BEGIN
  -- Validaciones por fila
  IF :NEW.precio < 0 OR :NEW.stock < 0 THEN
    RAISE_APPLICATION_ERROR(-20005, 'Precio/stock negativos no permitidos');
  END IF;

  -- Vinculamos al último evento de UPDATE_LIBROS si existe, si no creamos uno.
  SELECT NVL(MAX(id_evento),0) INTO v_id_evento
    FROM auditoria_eventos
   WHERE operacion = 'UPDATE_LIBROS';

  IF v_id_evento = 0 THEN
    INSERT INTO auditoria_eventos(usuario, operacion)
    VALUES (USER, 'UPDATE_LIBROS')
    RETURNING id_evento INTO v_id_evento;
  END IF;

  IF :OLD.precio <> :NEW.precio THEN
    INSERT INTO auditoria_detalle(id_evento, id_libro, campo, valor_old, valor_new)
    VALUES (v_id_evento, :OLD.id_libro, 'precio', TO_CHAR(:OLD.precio), TO_CHAR(:NEW.precio));
  END IF;

  IF :OLD.stock <> :NEW.stock THEN
    INSERT INTO auditoria_detalle(id_evento, id_libro, campo, valor_old, valor_new)
    VALUES (v_id_evento, :OLD.id_libro, 'stock', TO_CHAR(:OLD.stock), TO_CHAR(:NEW.stock));
  END IF;

  COMMIT;
END;
/

------------------------------------------------------------
-- 5) DEMOS rápidas 
------------------------------------------------------------

-- Procedimiento sin parámetros (masivo)
BEGIN
  sp_revalorizar_categoria_default; -- sube 10% en categoría 1
END;
/

-- Procedimiento con parámetros
BEGIN
  sp_ajustar_stock(1, 3);  -- suma 3 unidades al libro 1
END;
/

-- Funciones
SELECT fn_stock_disponible(1) AS stock_libro_1 FROM dual;
SELECT fn_valor_inventario_categoria(1) AS valor_cat_1 FROM dual;

-- Package (ajuste seguro + resumen)
BEGIN
  pkg_inventario.ajustar_stock_seguro(2, -1);
END;
/

DECLARE
  r pkg_inventario.t_resumen;
BEGIN
  r := pkg_inventario.resumen_categoria(1);
  DBMS_OUTPUT.PUT_LINE('Total libros cat1='||r.total_libros||'  Valor='||r.total_valor);
END;
/

-- Cualquier UPDATE masivo para que se vea la auditoría (stmt + row)
UPDATE libros SET precio = precio * 1.05 WHERE id_categoria = 2;
SELECT * FROM auditoria_eventos ORDER BY id_evento DESC;
SELECT * FROM auditoria_detalle ORDER BY id_detalle DESC;

